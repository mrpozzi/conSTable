rm(list=ls())#
gc()#
remove.packages("conSTable") #
detach("package:conSTable")#
#

#
library(devtools)#
#
install_github("conSTable",username="mrpozzi",ref="master")#

setwd("../data/")#

file <- "commodityContTab.csv"#
file0 <- "Comm.SZ.csv"#
filef <- "FeedConstraint.csv"#
FBS <- readFBS(file,file0,filef)#

#
balanceOne <- balanceFBS(FBS)#

balanceOne("Congo",2008,oset=c(30,30,40,50,50,10000),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#

aa <- balanceCountry(FBS,"Congo",oset=c(30,30,40,50,50,10000),prop=NULL, nIter = 10,verbose=TRUE)#

aa#

balanceAll(FBS,oset=c(30,30,40,50,50,10000),ncores=1)#

balanceOne("Italy",2008,oset=c(30,30,40,50,50,10000),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#

balanceOne("USA",2008,oset=c(30,30,40,50,50,10000),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#

balanceOne("Armenia",2008,oset=c(30,30,40,50,50,10000),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#

balanceCountry(FBS,"Armenia",oset=c(30,30,40,50,50,10000),prop=NULL, nIter = 10,verbose=TRUE)#

balanceCountry(FBS,"Congo",oset=c(30,30,40,50,50,10000),prop=NULL, nIter = 10,verbose=TRUE)#

balanceOne("1",2008,oset=c(100,100,100,100,100,10000),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#

FBS[["Italy"]][["2008"]]#

getAnywhere(".sampleTables")#

oset=c(30,30,40,50,50,10000)#

mu_tab#

FBS#

FBS[["Congo"]][["2008"]]#

FBS[["10"]][["2008"]]#

mu_Tab <- FBS[["10"]][["2008"]]$data#

mu_Tab#

fbs <- FBS[["10"]][["2008"]]#

nrow(mu_Tab)#

fbs$sd#

cbind(fbs$sd,t(oset%*%t(rep(1,nrow(mu_Tab)))))#

dim(mu_Tab)#

names(mu_Tab)#

colnames(mu_Tab)#

ncol(cbind(fbs$sd,t(oset%*%t(rep(1,nrow(mu_Tab))))))#

ncol(mu_Tab)#

fbs <- FBS[["1"]][["2007"]]#

fbs <- FBS[["1"]][["2008"]]#

fbs$data#

fbs$data[1,]#

summary(fbs$data[1,])#

attr(fbs)#

attr(FBS)#

?attr#

apply(fbs,2,summary)#

apply(fbs$data,2,summary)#

fbs$row_Tot[1]#

sum(fbs$data[1,])#

apply(fbs$data,1,sum(.,na.rm=T))#

attr(FBS,"countryMap")[]#

attr(fbs,"countryMap")#

attr(fbs,"countryMap")[]#

apply(fbs$data,1,sum)#
#

apply(fbs$data,2,summary)#
#

balanceOne("1",2008,oset=c(100,10,10,10,10,10),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#

balanceOne("1",2008,oset=c(10,10,10,10,10,1000),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#

?aggregate#

oset#

balanceOne("1",2008,oset=oset,prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#

conSTable::.sampleTables#

file_g <- "groupContTab.csv"#

FBS_g <- readFBS(file_g,file0,filef) #

file0#

structZero <- read.csv(file0, row.names=2)[,-1]!="num"#

		structZero <- read.csv(file0, row.names=1)[,-1]!="num"#

		structZero <- read.csv(file0, row.names=2)[,-2]!="num"#

		structZero <- read.csv(file0, row.names=2)[,-1]!="num"#

file_g#

file = file_g#

	rawData <- scan(file, what="", sep="\n",quote="\"")#

	header <- rawData[1]; rawData <- rawData[-1]#
	header  <- unlist(strsplit(header, ","))#
	rawData <- strsplit(rawData, ",")#
	rawData <- rawData[sapply(rawData,length)!=1]#

head(rawData)#

colN <- unlist(lapply(strsplit(whichCols,".",fixed=TRUE),"[[",1))#

whichCols=c("Imports.primary","Exports.primary","Feed.use","Seed.use","Losses","Industrial.use","Food.use","Stock.change")#

	colN <- unlist(lapply(strsplit(whichCols,".",fixed=TRUE),"[[",1))#

colN#

	structZero <- NULL#
	if(!is.null(file0)){#
		structZero <- read.csv(file0, row.names=2)[,-2]!="num"#
	}#

	feedConstraints <- NULL#
	if(!is.null(filef)){#
		feedConstraints <- read.csv(filef)#
		feedConstraints  <- feedConstraints[!duplicated(feedConstraints),]#
	}#

countries#

	names(countries)#

	countries <- sapply(rawData, `[`,2)#

	names(countries) <- sapply(rawData, `[`,1)#

sdCols=c("Imports.sd","Exports.sd")#

whichRowsNot=c("GRAND TOTAL")#

	countryData <- tapply(rawData, countries,function(country){#
		years <- sapply(country, `[`,4)#
		yearData <- tapply(country,years,function(year){#
			nm <- sapply(year,`[`,3)#
			fbs <- t(sapply(year,function(y) as.numeric(y[-(1:4)])))#
			rownames(fbs) <- nm#
			colnames(fbs) <- header[-(1:4)]#
			fbs[, whichCols[1:2]][fbs[,sdCols]==0] <- NA#
			fbs[, whichCols[1]] <- -fbs[, whichCols[1]]	#
			codeYear <- t(sapply(year,`[`,c(2,5)))#
			codeYear  <- codeYear[!duplicated(codeYear,margin=2),]#
			feed <- feedConstraints[feedConstraints[,1]==(codeYear[1])&feedConstraints[,2]==codeYear[2],3]#
			if(length(feed)>1) {#
				if(length(unique(feed))>1){#
					warning(paste("Constraints on Feed for",year[[1]][1],year[[1]][5],"have multiple values (choosing first).",sep=" "))#
					}#
				feedConstraints <- unique(feedConstraints)[1]#
			}#
			data <- fbs[!rownames(fbs) %in% whichRowsNot, whichCols]#
			colnames(data) <- colN#
			list(data=data,row_Tot=fbs[!rownames(fbs) %in% whichRowsNot,fixed],sd=fbs[!rownames(fbs) %in% whichRowsNot,sdCols],feed=feed)#
			})#
		yearData#
		})#

fixed="Production"#

	countryData <- tapply(rawData, countries,function(country){#
		years <- sapply(country, `[`,4)#
		yearData <- tapply(country,years,function(year){#
			nm <- sapply(year,`[`,3)#
			fbs <- t(sapply(year,function(y) as.numeric(y[-(1:4)])))#
			rownames(fbs) <- nm#
			colnames(fbs) <- header[-(1:4)]#
			fbs[, whichCols[1:2]][fbs[,sdCols]==0] <- NA#
			fbs[, whichCols[1]] <- -fbs[, whichCols[1]]	#
			codeYear <- t(sapply(year,`[`,c(2,5)))#
			codeYear  <- codeYear[!duplicated(codeYear,margin=2),]#
			feed <- feedConstraints[feedConstraints[,1]==(codeYear[1])&feedConstraints[,2]==codeYear[2],3]#
			if(length(feed)>1) {#
				if(length(unique(feed))>1){#
					warning(paste("Constraints on Feed for",year[[1]][1],year[[1]][5],"have multiple values (choosing first).",sep=" "))#
					}#
				feedConstraints <- unique(feedConstraints)[1]#
			}#
			data <- fbs[!rownames(fbs) %in% whichRowsNot, whichCols]#
			colnames(data) <- colN#
			list(data=data,row_Tot=fbs[!rownames(fbs) %in% whichRowsNot,fixed],sd=fbs[!rownames(fbs) %in% whichRowsNot,sdCols],feed=feed)#
			})#
		yearData#
		})#
#

file <- "commodityContTab.csv"#

	rawData <- scan(file, what="", sep="\n",quote="\"")#
	header <- rawData[1]; rawData <- rawData[-1]#
	header  <- unlist(strsplit(header, ","))#
	rawData <- strsplit(rawData, ",")#
	rawData <- rawData[sapply(rawData,length)!=1]#
	colN <- unlist(lapply(strsplit(whichCols,".",fixed=TRUE),"[[",1))#

	structZero <- NULL#
	if(!is.null(file0)){#
		structZero <- read.csv(file0, row.names=2)[,-1]!="num"#
	}#
	feedConstraints <- NULL#
	if(!is.null(filef)){#
		feedConstraints <- read.csv(filef)#
		feedConstraints  <- feedConstraints[!duplicated(feedConstraints),]#
	}#
	countries <- sapply(rawData, `[`,2)#
	names(countries) <- sapply(rawData, `[`,1)#
	countryData <- tapply(rawData, countries,function(country){#
		years <- sapply(country, `[`,5)#
		yearData <- tapply(country,years,function(year){#
			nm <- sapply(year,`[`,4)#
			fbs <- t(sapply(year,function(y) as.numeric(y[-(1:5)])))#
			rownames(fbs) <- nm#
			colnames(fbs) <- header[-(1:5)]#
			fbs[, whichCols[1:2]][fbs[,sdCols]==0] <- NA#
			fbs[, whichCols[1]] <- -fbs[, whichCols[1]]	#
			codeYear <- t(sapply(year,`[`,c(2,5)))#
			codeYear  <- codeYear[!duplicated(codeYear,margin=2),]#
			feed <- feedConstraints[feedConstraints[,1]==(codeYear[1])&feedConstraints[,2]==codeYear[2],3]#
			if(length(feed)>1) {#
				if(length(unique(feed))>1){#
					warning(paste("Constraints on Feed for",year[[1]][1],year[[1]][5],"have multiple values (choosing first).",sep=" "))#
					}#
				feedConstraints <- unique(feedConstraints)[1]#
			}#
			data <- fbs[!rownames(fbs) %in% whichRowsNot, whichCols]#
			colnames(data) <- colN#
			list(data=data,row_Tot=fbs[!rownames(fbs) %in% whichRowsNot,fixed],sd=fbs[!rownames(fbs) %in% whichRowsNot,sdCols],feed=feed)#
			})#
		yearData#
		})#

	attr(countryData,"countryMap") <- countries[!duplicated(countries)] 
	countryData#

file <- "commodityContTab.csv"#
file_g <- "groupContTab.csv"#
file0 <- "Comm.SZ.csv"#
filef <- "FeedConstraint.csv"#
FBS <- readFBS(file,file0,filef)#

FBS[["1"]][[]]#

FBS[["1"]][["2008"]]#

readFBS_group <- function(file,file0=NULL,filef,whichCols=c("Imports.primary","Exports.primary","Feed.use","Seed.use","Losses","Industrial.use","Food.use","Stock.change"),fixed="Production",sdCols=c("Imports.sd","Exports.sd"),whichRowsNot=c("GRAND TOTAL")){#
	Sys.setlocale(locale="C")#
	rawData <- scan(file, what="", sep="\n",quote="\"")#
	header <- rawData[1]; rawData <- rawData[-1]#
	header  <- unlist(strsplit(header, ","))#
	rawData <- strsplit(rawData, ",")#
	rawData <- rawData[sapply(rawData,length)!=1]#
	colN <- unlist(lapply(strsplit(whichCols,".",fixed=TRUE),"[[",1))#
	structZero <- NULL#
	if(!is.null(file0)){#
		structZero <- read.csv(file0, row.names=2)[,-2]!="num"#
	}#
	feedConstraints <- NULL#
	if(!is.null(filef)){#
		feedConstraints <- read.csv(filef)#
		feedConstraints  <- feedConstraints[!duplicated(feedConstraints),]#
	}#
	countries <- sapply(rawData, `[`,2)#
	names(countries) <- sapply(rawData, `[`,1)#
	countryData <- tapply(rawData, countries,function(country){#
		years <- sapply(country, `[`,4)#
		yearData <- tapply(country,years,function(year){#
			nm <- sapply(year,`[`,3)#
			fbs <- t(sapply(year,function(y) as.numeric(y[-(1:4)])))#
			rownames(fbs) <- nm#
			colnames(fbs) <- header[-(1:4)]#
			fbs[, whichCols[1:2]][fbs[,sdCols]==0] <- NA#
			fbs[, whichCols[1]] <- -fbs[, whichCols[1]]	#
			codeYear <- t(sapply(year,`[`,c(2,5)))#
			codeYear  <- codeYear[!duplicated(codeYear,margin=2),]#
			feed <- feedConstraints[feedConstraints[,1]==(codeYear[1])&feedConstraints[,2]==codeYear[2],3]#
			if(length(feed)>1) {#
				if(length(unique(feed))>1){#
					warning(paste("Constraints on Feed for",year[[1]][1],year[[1]][5],"have multiple values (choosing first).",sep=" "))#
					}#
				feedConstraints <- unique(feedConstraints)[1]#
			}#
			data <- fbs[!rownames(fbs) %in% whichRowsNot, whichCols]#
			colnames(data) <- colN#
			list(data=data,row_Tot=fbs[!rownames(fbs) %in% whichRowsNot,fixed],sd=fbs[!rownames(fbs) %in% whichRowsNot,sdCols],feed=feed)#
			})#
		yearData#
		})#
#
	attr(countryData,"countryMap") <- countries[!duplicated(countries)] #
	countryData#
	}#

feedConstraints[,1]#

debug(readFBS_group)#

l#

u#

where#

header#

rawData#

structZero#

head(structZero)#

head(feedConstraints)#

n#

s#

ls()#

whichCols#

countryData#

c#

undebug(readFBS_group)#

readFBS_group(file_g,file0,filef) #
#

readFBS_group <- function(file,file0=NULL,filef,whichCols=c("Imports.primary","Exports.primary","Feed.use","Seed.use","Losses","Industrial.use","Food.use","Stock.change"),fixed="Production",sdCols=c("Imports.sd","Exports.sd"),whichRowsNot=c("GRAND TOTAL")){#
	Sys.setlocale(locale="C")#
	rawData <- scan(file, what="", sep="\n",quote="\"")#
	header <- rawData[1]; rawData <- rawData[-1]#
	header  <- unlist(strsplit(header, ","))#
	rawData <- strsplit(rawData, ",")#
	rawData <- rawData[sapply(rawData,length)!=1]#
	colN <- unlist(lapply(strsplit(whichCols,".",fixed=TRUE),"[[",1))#
	structZero <- NULL#
	if(!is.null(file0)){#
		structZero <- read.csv(file0, row.names=2)[,-2]!="num"#
	}#
	feedConstraints <- NULL#
	if(!is.null(filef)){#
		feedConstraints <- read.csv(filef)#
		feedConstraints  <- feedConstraints[!duplicated(feedConstraints),]#
	}#
	countries <- sapply(rawData, `[`,2)#
	names(countries) <- sapply(rawData, `[`,1)#
	countryData <- tapply(rawData, countries,function(country){#
		years <- sapply(country, `[`,4)#
		yearData <- tapply(country,years,function(year){#
			nm <- sapply(year,`[`,3)#
			fbs <- t(sapply(year,function(y) as.numeric(y[-(1:4)])))#
			rownames(fbs) <- nm#
			colnames(fbs) <- header[-(1:4)]#
			fbs[, whichCols[1:2]][fbs[,sdCols]==0] <- NA#
			fbs[, whichCols[1]] <- -fbs[, whichCols[1]]	#
			codeYear <- t(sapply(year,`[`,c(2,5)))#
			codeYear  <- codeYear[!duplicated(codeYear,margin=2),]#
			browser()#
			feed <- feedConstraints[feedConstraints[,1]==(codeYear[1])&feedConstraints[,2]==codeYear[2],3]#
			if(length(feed)>1) {#
				if(length(unique(feed))>1){#
					warning(paste("Constraints on Feed for",year[[1]][1],year[[1]][5],"have multiple values (choosing first).",sep=" "))#
					}#
				feedConstraints <- unique(feedConstraints)[1]#
			}#
			data <- fbs[!rownames(fbs) %in% whichRowsNot, whichCols]#
			colnames(data) <- colN#
			list(data=data,row_Tot=fbs[!rownames(fbs) %in% whichRowsNot,fixed],sd=fbs[!rownames(fbs) %in% whichRowsNot,sdCols],feed=feed)#
			})#
		yearData#
		})#
#
	attr(countryData,"countryMap") <- countries[!duplicated(countries)] #
	countryData#
	}#

readFBS_group(file_g,file0,filef) #

feedConstraints#

feedConstraints[,1]==(codeYear[1])#

feedConstraints[,2]==codeYear[2]#

feedConstraints[,2]#

codeYear[2]#

			codeYear <- t(sapply(year,`[`,c(2,4)))#

codeYear#

Q#

	#
readFBS_group <- function(file,file0=NULL,filef,whichCols=c("Imports.primary","Exports.primary","Feed.use","Seed.use","Losses","Industrial.use","Food.use","Stock.change"),fixed="Production",sdCols=c("Imports.sd","Exports.sd"),whichRowsNot=c("GRAND TOTAL")){#
	Sys.setlocale(locale="C")#
	rawData <- scan(file, what="", sep="\n",quote="\"")#
	header <- rawData[1]; rawData <- rawData[-1]#
	header  <- unlist(strsplit(header, ","))#
	rawData <- strsplit(rawData, ",")#
	rawData <- rawData[sapply(rawData,length)!=1]#
	colN <- unlist(lapply(strsplit(whichCols,".",fixed=TRUE),"[[",1))#
	structZero <- NULL#
	if(!is.null(file0)){#
		structZero <- read.csv(file0, row.names=2)[,-2]!="num"#
	}#
	feedConstraints <- NULL#
	if(!is.null(filef)){#
		feedConstraints <- read.csv(filef)#
		feedConstraints  <- feedConstraints[!duplicated(feedConstraints),]#
	}#
	countries <- sapply(rawData, `[`,2)#
	names(countries) <- sapply(rawData, `[`,1)#
	countryData <- tapply(rawData, countries,function(country){#
		years <- sapply(country, `[`,4)#
		yearData <- tapply(country,years,function(year){#
			nm <- sapply(year,`[`,3)#
			fbs <- t(sapply(year,function(y) as.numeric(y[-(1:4)])))#
			rownames(fbs) <- nm#
			colnames(fbs) <- header[-(1:4)]#
			fbs[, whichCols[1:2]][fbs[,sdCols]==0] <- NA#
			fbs[, whichCols[1]] <- -fbs[, whichCols[1]]	#
			codeYear <- t(sapply(year,`[`,c(2,4)))#
			codeYear  <- codeYear[!duplicated(codeYear,margin=2),]#
			feed <- feedConstraints[feedConstraints[,1]==(codeYear[1])&feedConstraints[,2]==codeYear[2],3]#
			if(length(feed)>1) {#
				if(length(unique(feed))>1){#
					warning(paste("Constraints on Feed for",year[[1]][1],year[[1]][5],"have multiple values (choosing first).",sep=" "))#
					}#
				feedConstraints <- unique(feedConstraints)[1]#
			}#
			data <- fbs[!rownames(fbs) %in% whichRowsNot, whichCols]#
			colnames(data) <- colN#
			list(data=data,row_Tot=fbs[!rownames(fbs) %in% whichRowsNot,fixed],sd=fbs[!rownames(fbs) %in% whichRowsNot,sdCols],feed=feed)#
			})#
		yearData#
		})#
#
	attr(countryData,"countryMap") <- countries[!duplicated(countries)] #
	countryData#
	}#

FBS_g <- readFBS_group(file_g,file0,filef) #

FBS_g[["10"]][["2008"]]#

balanceOne <- balanceFBS(FBS_g)#

balanceOne("1",2008,oset=c(10,10,10,10,10,10),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#

balanceOne("1",2008,oset=c(0,0,0,0,0,10000),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#

warnings()#

balanceOne("1",2008,oset=c(0,0,0,0,0,2000),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#
#

fbs <- FBS_g[["1"]][["2008"]]#

fbs#

apply(fbs,1,sum)#

apply(fbs$data,1,sum)#

fbs$row_Tot#

conSTable <-#
function(muTab, rowTot, prop=NULL, shift=0, controlCol, nIter=100, N=10000,sdev=5,verbose=TRUE,objFun=function(tab){-colSums(tab)[1]},fixedRows=NULL,fixed=c(),transpose=FALSE,communicate=warnings,...){#
	if(transpose){#
		muTab <- t(muTab)#
		}#
	colTot <- colSums(muTab, na.rm=T)#
	colMu <- colMeans(muTab, na.rm=T)#
  if(!is.null(prop) & !all(shift==0)) stop("Either prop between 0 and 1 and shift 0 or prop NULL and shift > 0")#
	if(!is.null(prop)) {#
		if(any(prop > 1)) stop("prop must be a number/vector with value/values between 0 and 1")#
		} else if(all(shift==0)) stop("When prop is NULL shift must be > 0")#
	if(!(is.null(prop) & all(shift==0))){#
		bounds <- array(NA,c(dim(muTab),2))#
		dimnames(bounds) <- c(dimnames(muTab),list(c("Lower","Upper")))#
		if(!is.null(prop)){#
			if(missing(controlCol)) controlCol <- rbind(colTot*(1-prop*sign(colTot)),colTot*(1+prop*sign(colTot)))#
			if(!is.null(dim(prop))|(length(prop)==1)){#
				shift <- prop*sign(muTab)*muTab#
				} else {#
					shift <- as.matrix(do.call(cbind,lapply(1:length(prop),function(j) prop[j]*sign(muTab[,j])*muTab[,j] )))#
					}#
				} else {#
					if(missing(controlCol)) {#
						if(is.null(dim(shift))){#
							controlCol <- rbind(colTot-shift,colTot+shift)#
							} else {#
								colShift <- apply(shift,2,max)#
								controlCol <- rbind(colTot-nrow(muTab)*colShift,colTot+nrow(muTab)*colShift)#
								}#
						}#
					if(is.null(dim(shift))&(length(shift)!=1)){#
						shift <- as.matrix(do.call(rbind,lapply(1:nrow(muTab),function(i) shift)))#
						}#
					}#
			bounds[,,"Lower"] <- as.matrix(muTab - shift)#
			bounds[,,"Upper"] <- as.matrix(muTab + shift)#
			bounds[,,"Lower"][is.na(muTab)] <- bounds[,,"Upper"][is.na(muTab)] <- 0#
			muTab[is.na(muTab)] <- 0#
		 }#
	.sampleTables(rowTot,muTab,bounds,controlCol,nIter=nIter,N=N,sdev=sdev,verbose=verbose,transpose=transpose,fixedRows=fixedRows,fixed=fixed,objFun=objFun,...)#
#
	}#
.sampleTables <-#
function(n0,muTab, bounds,controlCol=NULL,controlRow=NULL,nIter=100,N=10000,sdev=5,verbose=TRUE,objFun=function(tab){-colSums(tab)[1]},fixed=c(),fixedRows=NULL,transpose=FALSE,keepArgs=FALSE,communicate=warnings,...){#
#
	call <- match.call()#
	if(keepArgs){#
		argz <- lapply(2:length(call),function(i)eval(call[[i]]))#
		names(argz) <- names(call)[2:length(names(call))]#
		}else argz <- list()#
	indZero <- unlist(lapply(1:nrow(muTab),function(i)all(muTab[i,]==0)&all(bounds[i,,1]==0)&all(bounds[i,,2]==0)))|(n0==0)#
	names(indZero) <- rownames(muTab)#
	if(is.null(names(indZero)) || length(unique(names(indZero)))!=length(indZero)){#
		names(indZero) <- 1:length(indZero)#
		}#
	leaveOut <- -which(indZero)#
	if(any(indZero)){#
		if(!is.null(fixedRows)){#
			fixed <- which((1:nrow(muTab))[leaveOut]%in%fixed)#
			}#
		muTab <- muTab[leaveOut,]#
		n0 <- n0[leaveOut]#
		if(!is.null(controlRow))controlRow <- controlRow[leaveOut,]#
		bounds <- bounds[leaveOut,,]#
		}#
#
	nr<-nrow(muTab)#
	nc<-ncol(muTab)#
	if(length(sdev==1)) sdev <- rep(sdev,nc)#
	okTab <- list()#
	if(is.null(controlRow)) controlRow <- do.call(rbind,lapply(1:nr,function(i){#
		if(all(c(muTab[i,nc],bounds[i,nc,])==0)) nc <- which.max(apply(bounds[i,,],1,function(x)diff(range(x))))#
		range(bounds[i,nc,])#
		}))#
	if(is.null(controlCol)) {#
		sdTab <- abs((bounds[,,2]-bounds[,,1])/2)#
		controlCol <- do.call(cbind,lapply(1:nc,function(j)range(rnorm(N,colSums(muTab),sqrt(colSums(sdTab^2))))))#
		}#
	iter <- t <- 1L#
	uniqueT <- 1#
	avuoto <- 0L#
	while(t <= nIter){#
		if(verbose) print(t)#
		sim <- do.call(rbind,lapply(1:nr,function(i){#
			if(i%in%fixed) return(fixedRows[fixed==i,])#
			rrow <- rep(NA,nc)#
			names(rrow) <- colnames(muTab)#
			repeat{#
				nc<-ncol(muTab)#
				if(all(c(muTab[i,nc],bounds[i,nc,])==0)){#
					nc <- max(which(muTab[i,-nc]!=0))#
					rrow[(1:length(rrow))>nc]<-0#
					maxTol <- which.max(apply(bounds[i,,],1,function(x)diff(range(x))))#
					rrow[-c(maxTol,(nc+1):length(rrow))] <- rtnorm(nc-1, mean=unlist(muTab[i,-c(maxTol,(nc+1):length(rrow))]), sd=sdev[(nc+1):length(rrow)], lower=bounds[i,-c(maxTol,(nc+1):length(rrow)),1],upper=bounds[i,-c(maxTol,(nc+1):length(rrow)),2])#
#
					rrow[maxTol] <- (n0[i]-sum(rrow[-c(maxTol,nc+1:length(rrow))]))#
					nc<-maxTol#
					}else{ #
						browser()#
						rrow[-nc] <- rtnorm(nc-1, mean=unlist(muTab[i,-nc]), sd=sdev[-nc], lower=bounds[i,-nc,1],upper=bounds[i,-nc,2])#
						rrow[nc] <- -n0[i]+sum(rrow[-nc])#
						}#
				if(rrow[nc]>=min(controlRow[i,]) & rrow[nc]<=max(controlRow[i,])) break#
				avuoto <- avuoto + 1L#
				if(avuoto > 1000L) warning("Running in Circles!!!")#
				}#
				if(verbose)cat("*")#
			return(rrow)#
			}))#
		if(verbose)cat("\n")#
		totCol <- colSums(sim)#
		cond <- sapply(1:nc,function(j)(totCol[j]>=controlCol[1,j] & totCol[j]<=controlCol[2,j]))#
		if(all(cond)){#
			avuoto <- 0L#
			if(t==1){#
				okTab[[uniqueT]] <- sim#
				attr(okTab[[uniqueT]],"mult") <- 0#
				}#
			dejavu <- FALSE#
			for(k in 1:uniqueT){#
				if(all(sim==okTab[[k]])){#
					attr(okTab[[k]],"mult") <- attr(okTab[[k]],"mult") + 1#
					break#
					}#
				}#
			if(!dejavu & t<nIter){#
				uniqueT <- uniqueT+1#
				okTab[[uniqueT]] <- sim#
				attr(okTab[[uniqueT]],"mult") <- 1#
				}#
			t <- t+1L#
			} else {#
				avuoto <- avuoto + 1L#
				if(avuoto > 1000L) warning("Running in Circles!!!")#
			}#
		iter <- iter + 1L#
        }#
      okTab <- okTab[1:uniqueT]#
      bestTab <- okTab[[which.min(unlist(lapply(okTab,objFun)))]]#
      row.names(bestTab) <- names(indZero[!indZero])#
      bestTab <- data.frame(bestTab)[names(indZero),]#
      row.names(bestTab) <- names(indZero)#
      bestTab[indZero,] <- 0#
      bestTab[, "Imports"] <- -bestTab[, "Imports"]#
      colnames(bestTab) <- colnames(muTab)#
      if(transpose){#
      	bestTab <- t(bestTab)#
      	okTab <- lapply(okTab,function(tab)t(tab))#
      	}#
#
      if(any(bestTab[!indZero,"Exports"] > n0 + bestTab[!indZero,"Imports"])){#
      	warning("Exports exceed Production + Imports")#
      	}#
      if(any(bestTab[!indZero,"Stock"] > 0.2 * (n0 + bestTab[!indZero,"Imports"] - bestTab[!indZero,"Exports"]))){#
      	warning("Stock cannot exceed more than 20% of Domestic Supply")#
      	}#
      if(is.infinite(abs(objFun(bestTab)))) {#
      	warning("Conditions Violated")#
      	return(NULL)#
      }#
      return(new("conTa",bestTab=as.matrix(bestTab),tables=okTab,iters=iter,objective=abs(objFun(bestTab)),call=call,args=argz))#
      }#
setClass("conTa",representation=representation(bestTab="matrix",#
                                              tables="list",#
                                              iters="integer",#
                                              objective="numeric",#
                                              call="call",#
                                              args="list"))#
#
setMethod("show",signature("conTa"),function(object){#
	cat("Call:\n")#
	print(object@call)#
	cat("\nOptimal Table: ")#
	print(object@bestTab)#
	cat("Number of Iterations: ")#
	cat(object@iters,"\n")#
	cat("Objective Function: ",attr(object@objective,"objName"))#
	cat(object@objective,"\n")#
	})#
setMethod("print",signature("conTa"),function(x,file=NULL,...){#
	cat("Call:\n")#
	print(x@call)#
	cat("\nOptimal Table: ")#
	print(x@bestTab)#
	cat("Number of Iterations: ")#
	cat(x@iters,"\n")#
	cat("Objective Function: ",attr(x@objective,"objName"))#
	cat(x@objective,"\n")#
	if(!is.null(file)) write.csv(x@bestTab,file=file,...)#
	})#
setMethod("[[", signature = "conTa", definition = function (x, i,j,..., drop = TRUE) {#
	if (!missing(j)) {stop("Wrong number of dimensions.")}#
	if (!missing(i)) {#
		return(switch(class(i),"character" = attributes(x)[[i]],#
		                       "integer" = attributes(x)[[i]],#
		                       "numeric" = attributes(x)[[i]],#
		                       "logical" = attributes(x)[c(i,rep(FALSE,length(attributes(x))-length(i)))],#
		                        stop("Subsetting object needs to be either a character, a numeric/integer or a logical.")#
		                        ))#
		}else{return(NULL)}#
   })#
#
setMethod("$", signature = "conTa", definition = function(x, name) {#
	 x[[name]]#
	 })#

conSTable <-#
function(muTab, rowTot, prop=NULL, shift=0, controlCol, nIter=100, N=10000,sdev=5,verbose=TRUE,objFun=function(tab){-colSums(tab)[1]},fixedRows=NULL,fixed=c(),transpose=FALSE,communicate=warnings,...){#
	if(transpose){#
		muTab <- t(muTab)#
		}#
	colTot <- colSums(muTab, na.rm=T)#
	colMu <- colMeans(muTab, na.rm=T)#
  if(!is.null(prop) & !all(shift==0)) stop("Either prop between 0 and 1 and shift 0 or prop NULL and shift > 0")#
	if(!is.null(prop)) {#
		if(any(prop > 1)) stop("prop must be a number/vector with value/values between 0 and 1")#
		} else if(all(shift==0)) stop("When prop is NULL shift must be > 0")#
	if(!(is.null(prop) & all(shift==0))){#
		bounds <- array(NA,c(dim(muTab),2))#
		dimnames(bounds) <- c(dimnames(muTab),list(c("Lower","Upper")))#
		if(!is.null(prop)){#
			if(missing(controlCol)) controlCol <- rbind(colTot*(1-prop*sign(colTot)),colTot*(1+prop*sign(colTot)))#
			if(!is.null(dim(prop))|(length(prop)==1)){#
				shift <- prop*sign(muTab)*muTab#
				} else {#
					shift <- as.matrix(do.call(cbind,lapply(1:length(prop),function(j) prop[j]*sign(muTab[,j])*muTab[,j] )))#
					}#
				} else {#
					if(missing(controlCol)) {#
						if(is.null(dim(shift))){#
							controlCol <- rbind(colTot-shift,colTot+shift)#
							} else {#
								colShift <- apply(shift,2,max)#
								controlCol <- rbind(colTot-nrow(muTab)*colShift,colTot+nrow(muTab)*colShift)#
								}#
						}#
					if(is.null(dim(shift))&(length(shift)!=1)){#
						shift <- as.matrix(do.call(rbind,lapply(1:nrow(muTab),function(i) shift)))#
						}#
					}#
			bounds[,,"Lower"] <- as.matrix(muTab - shift)#
			bounds[,,"Upper"] <- as.matrix(muTab + shift)#
			bounds[,,"Lower"][is.na(muTab)] <- bounds[,,"Upper"][is.na(muTab)] <- 0#
			muTab[is.na(muTab)] <- 0#
		 }#
	.sampleTables(rowTot,muTab,bounds,controlCol,nIter=nIter,N=N,sdev=sdev,verbose=verbose,transpose=transpose,fixedRows=fixedRows,fixed=fixed,objFun=objFun,...)#
#
	}#
#

.sampleTables <-#
function(n0,muTab, bounds,controlCol=NULL,controlRow=NULL,nIter=100,N=10000,sdev=5,verbose=TRUE,objFun=function(tab){-colSums(tab)[1]},fixed=c(),fixedRows=NULL,transpose=FALSE,keepArgs=FALSE,communicate=warnings,...){#
#
	call <- match.call()#
	if(keepArgs){#
		argz <- lapply(2:length(call),function(i)eval(call[[i]]))#
		names(argz) <- names(call)[2:length(names(call))]#
		}else argz <- list()#
	indZero <- unlist(lapply(1:nrow(muTab),function(i)all(muTab[i,]==0)&all(bounds[i,,1]==0)&all(bounds[i,,2]==0)))|(n0==0)#
	names(indZero) <- rownames(muTab)#
	if(is.null(names(indZero)) || length(unique(names(indZero)))!=length(indZero)){#
		names(indZero) <- 1:length(indZero)#
		}#
	leaveOut <- -which(indZero)#
	if(any(indZero)){#
		if(!is.null(fixedRows)){#
			fixed <- which((1:nrow(muTab))[leaveOut]%in%fixed)#
			}#
		muTab <- muTab[leaveOut,]#
		n0 <- n0[leaveOut]#
		if(!is.null(controlRow))controlRow <- controlRow[leaveOut,]#
		bounds <- bounds[leaveOut,,]#
		}#
#
	nr<-nrow(muTab)#
	nc<-ncol(muTab)#
	if(length(sdev==1)) sdev <- rep(sdev,nc)#
	okTab <- list()#
	if(is.null(controlRow)) controlRow <- do.call(rbind,lapply(1:nr,function(i){#
		if(all(c(muTab[i,nc],bounds[i,nc,])==0)) nc <- which.max(apply(bounds[i,,],1,function(x)diff(range(x))))#
		range(bounds[i,nc,])#
		}))#
	if(is.null(controlCol)) {#
		sdTab <- abs((bounds[,,2]-bounds[,,1])/2)#
		controlCol <- do.call(cbind,lapply(1:nc,function(j)range(rnorm(N,colSums(muTab),sqrt(colSums(sdTab^2))))))#
		}#
	iter <- t <- 1L#
	uniqueT <- 1#
	avuoto <- 0L#
	while(t <= nIter){#
		if(verbose) print(t)#
		sim <- do.call(rbind,lapply(1:nr,function(i){#
			if(i%in%fixed) return(fixedRows[fixed==i,])#
			rrow <- rep(NA,nc)#
			names(rrow) <- colnames(muTab)#
			repeat{#
				nc<-ncol(muTab)#
				if(all(c(muTab[i,nc],bounds[i,nc,])==0)){#
					nc <- max(which(muTab[i,-nc]!=0))#
					rrow[(1:length(rrow))>nc]<-0#
					maxTol <- which.max(apply(bounds[i,,],1,function(x)diff(range(x))))#
					rrow[-c(maxTol,(nc+1):length(rrow))] <- rtnorm(nc-1, mean=unlist(muTab[i,-c(maxTol,(nc+1):length(rrow))]), sd=sdev[(nc+1):length(rrow)], lower=bounds[i,-c(maxTol,(nc+1):length(rrow)),1],upper=bounds[i,-c(maxTol,(nc+1):length(rrow)),2])#
#
					rrow[maxTol] <- (n0[i]-sum(rrow[-c(maxTol,nc+1:length(rrow))]))#
					nc<-maxTol#
					}else{ #
						browser()#
						rrow[-nc] <- rtnorm(nc-1, mean=unlist(muTab[i,-nc]), sd=sdev[-nc], lower=bounds[i,-nc,1],upper=bounds[i,-nc,2])#
						rrow[nc] <- -n0[i]+sum(rrow[-nc])#
						}#
				if(rrow[nc]>=min(controlRow[i,]) & rrow[nc]<=max(controlRow[i,])) break#
				avuoto <- avuoto + 1L#
				if(avuoto > 1000L) warning("Running in Circles!!!")#
				}#
				if(verbose)cat("*")#
			return(rrow)#
			}))#
		if(verbose)cat("\n")#
		totCol <- colSums(sim)#
		cond <- sapply(1:nc,function(j)(totCol[j]>=controlCol[1,j] & totCol[j]<=controlCol[2,j]))#
		if(all(cond)){#
			avuoto <- 0L#
			if(t==1){#
				okTab[[uniqueT]] <- sim#
				attr(okTab[[uniqueT]],"mult") <- 0#
				}#
			dejavu <- FALSE#
			for(k in 1:uniqueT){#
				if(all(sim==okTab[[k]])){#
					attr(okTab[[k]],"mult") <- attr(okTab[[k]],"mult") + 1#
					break#
					}#
				}#
			if(!dejavu & t<nIter){#
				uniqueT <- uniqueT+1#
				okTab[[uniqueT]] <- sim#
				attr(okTab[[uniqueT]],"mult") <- 1#
				}#
			t <- t+1L#
			} else {#
				avuoto <- avuoto + 1L#
				if(avuoto > 1000L) warning("Running in Circles!!!")#
			}#
		iter <- iter + 1L#
        }#
      okTab <- okTab[1:uniqueT]#
      bestTab <- okTab[[which.min(unlist(lapply(okTab,objFun)))]]#
      row.names(bestTab) <- names(indZero[!indZero])#
      bestTab <- data.frame(bestTab)[names(indZero),]#
      row.names(bestTab) <- names(indZero)#
      bestTab[indZero,] <- 0#
      bestTab[, "Imports"] <- -bestTab[, "Imports"]#
      colnames(bestTab) <- colnames(muTab)#
      if(transpose){#
      	bestTab <- t(bestTab)#
      	okTab <- lapply(okTab,function(tab)t(tab))#
      	}#
#
      if(any(bestTab[!indZero,"Exports"] > n0 + bestTab[!indZero,"Imports"])){#
      	warning("Exports exceed Production + Imports")#
      	}#
      if(any(bestTab[!indZero,"Stock"] > 0.2 * (n0 + bestTab[!indZero,"Imports"] - bestTab[!indZero,"Exports"]))){#
      	warning("Stock cannot exceed more than 20% of Domestic Supply")#
      	}#
      if(is.infinite(abs(objFun(bestTab)))) {#
      	warning("Conditions Violated")#
      	return(NULL)#
      }#
      return(new("conTa",bestTab=as.matrix(bestTab),tables=okTab,iters=iter,objective=abs(objFun(bestTab)),call=call,args=argz))#
      }#
setClass("conTa",representation=representation(bestTab="matrix",#
                                              tables="list",#
                                              iters="integer",#
                                              objective="numeric",#
                                              call="call",#
                                              args="list"))#
#
setMethod("show",signature("conTa"),function(object){#
	cat("Call:\n")#
	print(object@call)#
	cat("\nOptimal Table: ")#
	print(object@bestTab)#
	cat("Number of Iterations: ")#
	cat(object@iters,"\n")#
	cat("Objective Function: ",attr(object@objective,"objName"))#
	cat(object@objective,"\n")#
	})#
setMethod("print",signature("conTa"),function(x,file=NULL,...){#
	cat("Call:\n")#
	print(x@call)#
	cat("\nOptimal Table: ")#
	print(x@bestTab)#
	cat("Number of Iterations: ")#
	cat(x@iters,"\n")#
	cat("Objective Function: ",attr(x@objective,"objName"))#
	cat(x@objective,"\n")#
	if(!is.null(file)) write.csv(x@bestTab,file=file,...)#
	})#
setMethod("[[", signature = "conTa", definition = function (x, i,j,..., drop = TRUE) {#
	if (!missing(j)) {stop("Wrong number of dimensions.")}#
	if (!missing(i)) {#
		return(switch(class(i),"character" = attributes(x)[[i]],#
		                       "integer" = attributes(x)[[i]],#
		                       "numeric" = attributes(x)[[i]],#
		                       "logical" = attributes(x)[c(i,rep(FALSE,length(attributes(x))-length(i)))],#
		                        stop("Subsetting object needs to be either a character, a numeric/integer or a logical.")#
		                        ))#
		}else{return(NULL)}#
   })#
#
setMethod("$", signature = "conTa", definition = function(x, name) {#
	 x[[name]]#
	 })#

balanceOne("1",2008,oset=c(30,30,40,50,50,10000),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#

balanceOne("1",2008,oset=c(30,30,40,50,50,10000),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#
#

balanceOne("1",2008,oset=c(0,0,0,0,0,2000),prop=NULL, nIter = 10,objF = function(tab){-colSums(tab)[1]},verbose=TRUE)#

#
remove.packages("conSTable") #
detach("package:conSTable")#

library(devtools)#

install_github("conSTable",username="marcogarieri",ref="master")#

library(conSTable)#

getwd()#

file <- "commodityContTab.csv"#
file_g <- "groupContTab.csv"#
file0 <- "Comm.SZ.csv"#
filef <- "FeedConstraint.csv"#
FBS <- readFBS(file,file0,filef)#
FBS_g <- readFBS_group(file_g,file0,filef) #

FBS_g[["1"]][["2008"]]#

conSTable::conSTable#

remove.packages("conSTable") #
detach("package:conSTable")#
#

