%\VignetteIndexEntry{conSTableDemo}
%\VignettePackage{conSTable}

%\VignetteDepends{conSTable}
%\VignetteDepends{msm}

%\newcounter{enumi_saved}
%\setcounter{enumi_saved}{\value{enumi}}
%\setcounter{enumi}{\value{enumi_saved}}

\documentclass[letterpaper,pdf,english]{article}

\usepackage[utf8]{inputenc} 
\usepackage{amsmath}
\usepackage[affil-it]{authblk}


<<results=hide,echo=FALSE>>=
options(width = 90)
set.seed(17)
@ 

\SweaveOpts{prefix.string=plotsconSTable,eps=FALSE,echo=TRUE}


\usepackage{times}
\usepackage{hyperref}
\usepackage{color}
\usepackage{babel}
\usepackage{graphicx}



\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{lscape}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfuncarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}

\newtheorem{theorem}{Theorem}
\newtheorem{algorithm}{Algorithm}


\newcommand{\E}{\mathbb{E}}
\renewcommand{\P}{\mathbb{P}}
\newcommand{\bxx}{{\mathbf {x}}}


\usepackage[margin=1in]{geometry}
%\usepackage{fancyhdr}
%\pagestyle{fancy}
%\rhead{}
%\renewcommand{\footrulewidth}{\headrulewidth}

\title{conSTable Tutorial}
\author{Marco Garieri, Natalia Golini, Luca Pozzi}
\affil{Consultants ESS Division, FAO}
%\url{http://www.ceremade.dauphine.fr/~xian}}


\date{Modified: February 21th, 2014, Compiled: \today}


\begin{document}
\SweaveOpts{concordance=TRUE}
\maketitle


\begin{abstract}

conSTable is an R package designed to address the reconstruction of unreliable or missing values in partially observed tables using a sampling strategy. The package has been developed within the Statistical Division (ESS) at the Food and Agricultural Organization (FAO) of the United Nations to solve the problem of balancing the Food Balance Sheets (FBSs). FBS are real valued matrices with structural zeros, i.e. entries constrained to be zeroes, whose rows and columns have to satisfy a series of equality constraints. The cell values are only partially reliable due to measurement and reporting error. We will go through a real world example to illustrate the functionalities of the package

\end{abstract}


\section{Introduction}

A few initial remarks are important before getting started with the tutorial. This document is written for first-time users of the conSTable package. It is not a reference manual, nor does it contain the technical details. In \cite{garieri2015} the sampling strategy for generating plausible (FBSs) is shown.  Using of conSTable doesn’t require  proficiency in R. Nonetheless, some degree of familiarity with R will help with more complex modeling tasks.
As pointed out in Garieri et al. (2015a), the algorithm implemented in this package is developed for sampling plausible tables with limited information. This methodology can be applied to any balancing problem, e.g. balancing of Input Output tables, Social Accounting Matrix, etc.
The functionalities of conSTable are shown in the contest of two-way tables. The real world example are the FBSs of the 169 countries belonging to Agricultural Market Information System (AMIS) for years 2007-2012 and following the sampling strategy proposed in  Garieri et al. (2015a). A careful reading of the cited paper is strongly recommended. 

The package is currently available at \url{https://github.com/mrpozzi/conSTable/tree/develop} and, it has been integrated into Statistical Working System (SWS) of FAO and is directly executable by FAO staff.
conSTable requires R, version 3.1.2 or higher. R is an open source statistical software which can be downloaded at \url{http://cran.r-project.org/}. Another requirement is package \Rcode{msm}.
Future directions of development include the option of using different prior distribution (i.e., normal skewness), additional constraints on the columns and many others.


\section{First Steps with \Rpackage{conSTable}}

To install the package from github we need to load the package\Rpackage{devtools}
<<init>>=
if(!require(conSTable)){
  library(devtools)
  install_github("mrpozzi/constable/tree",ref="develop")
}
@ 

As discussed in Garieri et al. (2015a), the function requires three
different files (a sample is included with the package).
<<files>>=
file <- system.file("extdata", "Adj.commodityContTab_db.csv",package="conSTable")
file0 <- system.file("extdata", "Comm.SZ.csv",package="conSTable")
filef <- system.file("extdata", "Adj.feedrange.csv",package="conSTable")
@


<<data,echo=FALSE>>=
commo <- read.csv(file)
zeroes <- read.csv(file0)
feedf <- read.csv(filef)
country <- "126"
year <- "2011"
@ 


The first is a csv file containing prior information (expected value expressed in Kcal/cap/day and variability) given by experts (FAO staff) for the FBSs of the 169 countries belonging to Agricultural Market Information System (AMIS) in 2007-2012.  This is a minimal requirement, which can accommodate the user’s needs.


The header of the csv file is:

<<header,echo=FALSE>>=
   colnames(commo) 
@ 

For these FBSs, the experts (FAO staff) have assumed that the only reliable information (consolidated term) comes from “Production” and that the balance identity to be respected is the following:
\begin{eqnarray*}\label{balance}
\textrm{Production}_{i,c,t} = -\textrm{Total Imports}_{i,c,t} +
\textrm{Total Exports}_{i,c,t} + \textrm{Feed} \\
\textrm{Seed}_{i,c,t} + \textrm{Losses}_{i,c,t} +
  \textrm{Industrial}_{i,c,t} - \textrm{Stock}_{i,c,t}
\end{eqnarray*}

for each commodity $i$ in a given country $c$ during the period $t$.


Because for each commodity, the expected value for Stock was obtained
as difference between Production and the remaining terms, all the FBSs
are balanced in input. See Section 2.2 in Garieri et al. (2015a) and
the references cited therein to understand how prior information were
generated. The sd variables in the dataset represent the variability
of the respective totals, expressed in terms of standard deviation.

The second file cointains data for the structural zeroes, i.e. values constrained to be zero for specified commodity for some terms of the balance identity \eqref{balance}. These values are not country-variant and year-variant. 

<<zeroes,echo=FALSE>>=
head(zeroes)
@

Structural zeros data are indicated by blank cells.

The third file contains the expected value of the total column of Feed and the respective lower and upper bound, for each country and year. 

<<feed, echo=FALSE>>=
head(feedf)
@ 


These data represent constraint column total of Feed coming from subject matter knowledge. Lower and upper  bounds delimit the range of values within which the sampled estimate of total column of Feed.use must fall. Information on FBS.mult can be ignored.

Now we can read the data, the package has a function for this task and
for formatting the data properly

<<read1>>=
FBS <- readFBS(file,file0,filef)
@ 

\Robject{FBS} is a nested list indexed by country and year, where:
\begin{itemize}
\item \Robject{FBS{[[}country{]]}{[[}year{]]}\$data} is a commodities by usage matrix
with the expected value of the commodity allocated to the specific
usage (e.g. Food, Feed, etc..). 
\item \Robject{FBS{[[}country{]]}{[[}year{]]}\$feed} is
a vector with the lower and upper bounds on Feed.
\item \Robject{FBS{[[}country{]]}{[[}year{]]}\$sd} is a matrix with the
  variabilities for each value of \Robject{FBS{[[}country{]]}{[[}year{]]}\$data}
\item \Robject{FBS{[[}country{]]}{[[}year{]]}\$row\_Tot} is a vector with the
  Production of each commodity. This represents a constraint on the
  total of the row (commodity).
\end{itemize}


\section{Main Functionalities of the Package}

The package include functions to balance:

\begin{enumerate}
  \item A single country for a single year: \Robject{balanceFBS}
    \item A single country for all the years provided in input: \Robject{balanceCountry}
      \item all countries in input for all the years: \Robject{balanceAll}  
  \end{enumerate}

  \subsection{Balancing a Country for a given Year}
  
  
  The function for balancing a single combination Country\/Year exploits the principle of function closure to create a function which encapsulates the data and can then be re-used multiple times with different options:
  
<<balanceOne>>=
balanceOne <- balanceFBS(FBS)
oneTab <- balanceOne("9",2012,oset=c(30,30,30,30,30,10000),
                     nIter=100,verbose=FALSE,checks="none",feedShift=30)
@

  
  Where the input is:
  
  \begin{itemize}
\item \Robject{sanityCheck}: if \Rcode{TRUE} the algorithm checks, in the input stage, if the total of Feed in the table \Robject{FBS{[[}country{]]}{[[}year{]]}\$data} falls in the boundaries given by \Robject{FBS{[[}country{]]}{[[}year{]]}\$feed}. 
\item \Robject{country}: the country of interest.
\item \Robject{year}: the year of interest.
\item \Robject{oset}: a vector of the same length of the number of columns. It defines the variability for each column in absolute terms of the expected values for each column.  If \Rcode{oset=NULL} then the variability of each commodity in each column will be assumed to be $20\%$ of the total of the respective column. See formula (5) in Section 4 in \cite{garieri2015} for more details. At the moment, StockVar variability is not relevant, since StockVar is calculated, for each commodity, as residual.
\item \Robject{prop}: must be a number between 0 and 1 or a vector of length 6 with values in the same range. It expresses the variability on a cell value in terms of a percentage of such value. To be used in an analogous way as \Robject{oset}. Either \Robject{prop} or \Robject{oset} have to be defined.
\item \Robject{n.iter} is the number of iterations of the
  sampler. The function will generate a single FBS per iteration and
  the best will be chosen using the objective function and the constraints.
 \item \Robject{verbose}: if \Rcode{TRUE} progess messages are printed
  to screen.
  \item \Robject{writeTab}: if \Rcode{TRUE} the optimal balanced FBS is written in a csv file in the working directory.
    
\item \Robject{checks}: if \Rcode{"all"} the algorithm checks the following conditions: 
  \begin{enumerate}
\item Exports $<$ Production $+$ Imports
\item Stock $<$ $20\%$ of Domestic Supply
\end{enumerate}
If \Rcode{"none"} the above checks will not stop the algorithm but will throw warnings.
\end{itemize}

At the time, the algorithm does not stop if the previous conditions are not respected but returns warnings.
The algorithm stops if:
  \begin{enumerate}
\item Production has negative values in \Rcode{FBS{[[}country{]]}{[[}year{]]}\$row\_Tot}
\item Imports  has positive values in \Rcode{FBS{[[}country{]]}{[[}year{]]}\$data}, because it can only take negative values in the balance identity (1);
\item Exports has negative values in \Rcode{FBS{[[}country{]]}{[[}year{]]}\$data}, because it can only take positive values in the balance identity (1);
\item null rows have not null row sums. 
  \end{enumerate}
The function \Rfunction{balanceOne} returns an object with the
following fields:
\begin{itemize}
  \item \Rcode{bestTab}: the table with the best value of the
    objective funtion.
\item \Rcode{tables}: list of the all sampled balanced FBSs.
\item \Rcode{iters}: number of iterations that corresponds to the number of sampled balanced FBSs.
\item \Rcode{objective}: value of the objective function for the best table.
\end{itemize}

We recall that, at the moment, the algorithm requires the input table to be balanced in input. The reason is that, with  rows difficult to be sampled, after several attempts it gives the input rows in output.\\
If the optimal table, after applying the objective function, does not respect the feed ranges given by expert, the algorithm will start again, chaning the oset parameter for the feed column, taking half of the previous attempt. This process will be recursive until the optimal table respect the feed constrains.

\subsection{Balancing a Country for every Year}

To balance a country for all the years available, type the following\\
<<balanceCountry,echo=TRUE,eval=FALSE>>=
countryTab <- balanceCountry(FBS,"Congo",oset=c(30,30,40,50,50,1e4), nIter=10,verbose=FALSE)
@


This function has the same inputs as \Rfunction{balanceFBS}  and
    provides a list in output with one of the objects described above
    for every year.
    
    This function implements one further constraint that links the
    optimal FBS to the one of the year before. The table to be chosen
    is the one that respects the constraint
    $$
    |\textrm{Tot. Food}_{t+1}-\textrm{Tot. Food}_t|\le150 \textrm{Kcal/cap/day}
    $$
    If this constraint can not be satisfied by the sampled tables,
    then the algorithm will choose the table with the best value of
    the objective function that minimizes $|\textrm{Tot. Food}_{t+1}-\textrm{Tot. Food}_t|$.
      
  \subsection{Balancing every Country for every Year}
To balance all the years and countries in the data we use a command like
<<balanceAll, eval=FALSE, echo=TRUE>>=
allTab <- balanceAll(FBS,oset=c(30,30,40,50,50,10000),feedShift=20,verbose=FALSE)
@ 

\section{An Example: Italy in 2011}

Let's now look at the data for Italy for year 2011. Note how the user
can see the list o available countries
<<countries>>=
head(attr(FBS,"countryMap"))
@ 

and the list of years for that country as
<<year>>=
head(names(FBS[[attr(FBS,"countryMap")[["Italy"]]]]))
@ 

<<setupItaly,echo=FALSE>>=
country<-"106"
year<-"2011"
@ 
Let's run the algorithm for that combination
<<balanceItaly>>=
balanceOne<-balanceFBS(FBS)
set.seed(181282)
output<-balanceOne("Italy",2011,oset=c(30,30,40,50,50,10000),nIter = 100,verbose=FALSE,writeTab=FALSE, checks="none",sanityCheck=TRUE)
@ 


In this case we sample 100  balanced tables. Because Italy is
considered saturated country in term of Dietary Energy Supply
(i.e. 3539 Kcal/Cap/Day) by experts, the "optimal balance table" is
the one has the lowest total of the Food column. 


We can plot the objective function value for each of the sampled tables
\begin{figure}
\centering
<<loss-plot, fig=TRUE, eps=FALSE,echo=FALSE>>=
objfun<-unlist(lapply(1:length(output$tables),function(i)sum(output$tables[[i]][,7])))
par(cex.axis=1,cex.main=1,cex.lab=1)
plot(objfun,xlab="Sampled Balanced Tables",ylab="Sum of Column Food",pch=16,lwd=1)
abline(h=min(objfun),col="red",lty=5,lwd=2)
segments(which.min(objfun),min(objfun),3,0,col="red",lty=5, lwd=2)
@
\end{figure}
The best table is accessible at \Rcode{output\$bestTab} and written to
the csv \Rcode{"Italy2011.csv"} if you run the algorithm with option \Rcode{writeTab=TRUE}

\newpage
\begin{thebibliography}{30}


\bibitem{garieri2015}
Garieri M., Golini, N. and Pozzi L. \emph{Placeholder}. (2015).



\end{thebibliography}



\section*{SessionInfo}

<<sessionInfo,results=tex,echo=FALSE>>=
toLatex(sessionInfo())
@ 

\end{document}

